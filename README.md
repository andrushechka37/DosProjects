# Resident
Программа выводит значения регистров во время работы других программ. 

## Реализация
В начале адресного пространства расположена таблица, в которой хранится места кода-обработчиков. Чтобы не изменять поведение системы после нашей собственной обработки происходит передача управления старому обработчику. 

В случае нажатия горячей клавиши передача управления старому обработчику не происходит.

Сохранение адреса старого обработчика происходит при изменении таблицы прерываний. Во избежании ситуации, когда смещение прерывания уже изменено, а сегмент еще нет, происходит прерывание, были использованы инструкции cli и sti, которые отключают и включают прерывания
```assembly
cli
mov dedault_IRQ0_address_offset, bx                                
mov bx, es                                                         
mov dedault_IRQ0_address_segment, bx   
sti                            
```
Передача управление происходит через long jump:

```assembly
db 0EAh					        ; long jump
dedault_IRQ1_address_offset   dw 0		; long jump /dedault_IRQ1_address_segment/ : /dedault_IRQ1_address_offset/
dedault_IRQ1_address_segment  dw 0		; ---------------------------------------------------------------
```

Чтобы обновлять значения регистров, я переписал прерывание, которое отвечает за таймер процессора, происходящее каждые 55ms. Во время прерывания сначала вызывается функция отрисовки рамки, после управление передается старому обработчику.

![alt text](<images/Снимок экрана 2024-06-05 в 23.10.19.png>)

# CRACK
## Задание: взломать *.com файл при помощи различных утилит.

## В работе использовались:
+ IDA
+ Turbo Debugger
+ Hex editor in VSCode 

# Ход работы

## Поиск уязвимостей в коде оппонента и использование слабых мест программы:
При помощи IDA был дизассемблирован и тщательно отсмотрен файл оппонента. Была найдена уязвимость, проявляющаяся при переполнении буфера: правильный пароль лежал в памяти рядом с буфером. Этот пароль был изменен на 111111, после чего было введено 33333, тк в функции проверки пароля каждый введенный символ уменьшался на 2.
![overflow](/images/overflow.png)
![crack](/images/crack.png)

## Взлом при помощи бинарного патча

При просмотре кода программы был замечен jump, "прыгающий" на завершение программы, вместо предоставления доступа. Этот досадный участок кода был "заNOPан" при помощи программы `crack_file.cpp`.

![grapth](/images/grapth.png)
![hex](/images/hex.png)

После нашего патча программа наконец работает корректно, принимая буквально любой пароль за верный:
![patch](/images/patch.png)


## Crackme, написанный для оппонента:

### Программа имела следующую структуру:
![grap](/images/12.svg)

Программа имела следующую уязвимость:

После буфера в памяти лежала канарейка "abc", а следом за ней лежал флаг правильности пароля, поэтому правильный взлом имел вид "любой текст размера 8 | abc | еще что-то"

![crackme_error](/images/crackme_error.png)

> [!CAUTION]
> # Далее идет развлекательный участок README, написанный, чтобы репозиторий выглядел повеселее.




## RAMKA
## Draws ramka with given parametres:

![ramka](/images/ramk.png)


## Str func
### Some mem_funcs realized in assembler
#### Example:

![str1](/images/1.png)
![str2](/images/2.png)